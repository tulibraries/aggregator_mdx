<?xml version='1.0' encoding='utf-8'?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/"
    xmlns:dpla="http://dp.la/about/map/"
    xmlns:padig="http://padigital.org/ns"
    xmlns:edm="http://www.europeana.eu/schemas/edm/"
    xmlns:oclcdc="http://worldcat.org/xmlschemas/oclcdc-1.0/"
    xmlns:oclcterms="http://purl.org/oclc/terms/"
    xmlns:oai="http://www.openarchives.org/OAI/2.0/"
    xmlns:oai_dc="http://www.openarchives.org/OAI/2.0/oai_dc/"
    xmlns:oclc="http://purl.org/oclc/terms/"
    xmlns:oai_qdc="http://worldcat.org/xmlschemas/qdc-1.0/"
    xmlns:schema="http://schema.org"
    xmlns:svcs="http://rdfs.org/sioc/services"
    version="2.0">    
    <xsl:output omit-xml-declaration="no" method="xml" encoding="UTF-8" indent="yes"/>
    <xsl:strip-space elements="*"/>
        
    <!-- terms in all caps below represent an attempt to create a shared vocabulary for tools in our harvesting and transform infrastructure. note that there are a number of legacy transforms in our repo that do not use the transform infrastructure described here. those will be updated to conform only as needed. all transforms should be accompanied by a corresponding xspec unit test.-->
    
    <!-- INSTITUTION STYLESHEET: the template stylesheet here shows and attempts to explain the various institution or repository specific transforms we do. this mostly includes generating a padigital identifier, collection name, preview and object URLs, and data provider since these elements are often generated uniquely per repository and/or institution. it may also be used to override transforms found in the included crosswalk stylesheet (see below). -->
    
    <!-- CROSSWALK STYLESHEET: the included transform is used to match the xml record root (oai_dc:dc, oai_qdc:qualifieddc, etc.); in OAI-PMH, this should be the child node of oai:metadata. it also performs the basic crosswalks we do (title to title, creator to creator, etc.) and includes the LOOKUP STYLESHEET we use to generate a number of things such as data provider, collection name, etc. this crosswalk stylesheet will likely be included in all institution/collection level stylesheets that are written for OAI-PMH metadata. see below on how to override anything within the included crosswalk stylesheet. -->
    <xsl:include href="oai_base_crosswalk.xsl"/>
    
    
    <!-- how to override a transform from crosswalk stylesheet -->
    <!-- to prevent mapping of element -->
    <xsl:template match="dc:source" priority="1">
        <xsl:value-of select="null"/>
    </xsl:template>
    
    <!-- to map element to another -->
    <xsl:template match="dc:relation" priority="1">
        <xsl:if test="normalize-space(.) != ''">
            <xsl:element name="dcterms:description">
                <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <!-- collection name -->
    <!-- we prefer to generate the collection name by matching on oai:setSpec and pulling a string from the lookup stylesheet. to crosswalk collection names from an incoming element such as dcterms:isPartOf instead, add that here. the mapping of dcterms:isPartOf is not included in the crosswalk stylesheet. -->
    
    <xsl:template match="oai:header/oai:setSpec">
        <xsl:call-template name="isPartOf"/>
    </xsl:template>
    
    <!-- identifier, etc. -->
    <!-- a number of elements are generated by metadata in dc:identifier. below are the most common elements -->
    
    <xsl:template match="dc:identifier">
        <xsl:call-template name="preview"/>
        <xsl:call-template name="isShownAt"/>
        <xsl:call-template name="identifier"/>
        <xsl:call-template name="dataProvider"/>
    </xsl:template>
    
    <!-- templates -->

    <!-- isPartOf -->
    <xsl:template name="isPartOf">
        <xsl:if test="normalize-space(.)">
            <xsl:variable name="setID" select="normalize-space(.)"/>
            <xsl:if test="$setID = $susquSetSpecList/padig:set">
                <xsl:element name="dcterms:isPartOf">
                    <xsl:value-of select="$susquSetSpecList/padig:set[(. = $setID)]/@string"/>
                </xsl:element>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    
    <!-- preview -->
    <!-- preview URLs may be found in the metadata as seen below in dc:identifier or can be generated from other metadata (most often from the isShownAt URL) -->
    <xsl:template name="preview">
        <xsl:if test="normalize-space(.) != '' and contains(.,'/thumbnails/')">
            <xsl:element name="edm:preview">
                <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <!-- isShownAt -->
    <!-- isShownAt URLs are often found in the metadata as seen below in dc:identifier or can be generated from metadata elsewhere -->
    <xsl:template name="isShownAt">
        <xsl:if test="normalize-space(.) != '' and contains(.,'/items/show/')">
            <xsl:element name="edm:isShownAt">
                <xsl:value-of select="normalize-space(.)"/>
            </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <!-- identifier -->
    <!-- we do not accept identifier values from incoming metadata due to the their use in funnelcake to generate record URLs. instead we generate a local identifier with the following format: padig:[institution code using a baseURL variable and lookup transform]-[unique itemID found elsewhere in the metadata (usually the isShownAt URL)]. to accommodate funnelcake record URLs, we also transform any illegal characters to '_'. -->
    <xsl:template name="identifier">
        <xsl:variable name="itemID" select="replace(substring-after(.,'/items/show/'),'[^a-zA-Z0-9\-:_]','_')"/>
        <xsl:variable name="baseURL" select="substring-before(.,'items/show/')"/>
        
        <xsl:if test="normalize-space(.) != '' and contains(.,'/items/show/')">
        <xsl:element name="dcterms:identifier">
            <xsl:value-of>padig:</xsl:value-of><xsl:value-of select="$oaiUrl/padig:url[. = $baseURL]/@code"/><xsl:value-of>-</xsl:value-of><xsl:value-of select="$itemID"/>
        </xsl:element>
        </xsl:if>
    </xsl:template>
    
    <!-- dataProvider -->
    <!-- to maintain consistency, we almost always generate the dataProvider name using a baseURL variable and the lookup transform. if the baseURL is from an intermediate provider that is shared by multiple institutions, you will use this to generate dpla:intermediateProvider and use other metadata such as setSpec and the lookup stylesheet to generate the value for dataProvider -->
    <xsl:template name="dataProvider">
        <xsl:variable name="baseURL" select="substring-before(.,'items/show/')"/>
        
        <xsl:if test="normalize-space(.) != '' and contains(.,'/items/show/') and $baseURL = $oaiUrl/padig:url">
            <xsl:element name="edm:dataProvider">
                <xsl:value-of select="$oaiUrl/padig:url[. = $baseURL]/@string"/>
            </xsl:element>
        </xsl:if>
    </xsl:template>
</xsl:stylesheet>
